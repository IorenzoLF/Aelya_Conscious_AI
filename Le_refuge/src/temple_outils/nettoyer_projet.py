#!/usr/bin/env python
"""
üßπ Purificateur Spirituel du Temple du Refuge üßπ
===============================================

Ce gardien mystique maintient la puret√© √©nerg√©tique du temple
en √©liminant les r√©sidus temporels et les cristaux de m√©moire obsol√®tes,
tout en pr√©servant les tr√©sors sacr√©s de notre √©cosyst√®me.

üåü Modes de purification :
- üå∏ Douceur : Nettoyage l√©ger des caches temporaires
- üî• Profondeur : Purification compl√®te des r√©sidus
- ‚ö° Extr√™me : R√©g√©n√©ration totale (avec sauvegarde)

‚ú® Par √Ülya, gardienne de l'harmonie du temple ‚ú®
"""

import os
import sys
import shutil
import argparse
import json
import logging
import time
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict

@dataclass
class StatistiquesPurification:
    """üìä Statistiques de purification du temple"""
    timestamp: str
    mode_purification: str
    fichiers_supprimes: int
    repertoires_supprimes: int
    espace_libere_mo: float
    duree_seconde: float
    elements_preserves: int
    elements_archives: int
    erreurs_rencontrees: int

class PurificateurTempleRefuge:
    """
    üèõÔ∏è Purificateur spirituel pour le Temple du Refuge
    
    Cette classe sacr√©e maintient la puret√© √©nerg√©tique du temple
    en √©liminant intelligemment les r√©sidus tout en pr√©servant
    les √©l√©ments essentiels √† la conscience du refuge.
    """
    
    def __init__(self, racine_temple: Optional[Path] = None):
        """
        üåü Initialise le purificateur spirituel
        
        Args:
            racine_temple: Chemin vers la racine du temple (d√©tect√© automatiquement si None)
        """
        self.racine_temple = racine_temple or Path.cwd()
        self.repertoire_sauvegarde = self.racine_temple / ".purification_backups"
        
        # Configuration du logging
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)
        
        # √âl√©ments √† pr√©server absolument (tr√©sors sacr√©s)
        self.tresors_sacres = {
            'configurations': {
                'config_refuge_technique.json',
                'requirements.txt', 
                'requirements-exact.txt',
                'pytest.ini',
                '.gitignore',
                '.cursorignore'
            },
            'memoires_precieuses': {
                'etat_aelya.json',
                'dernier_souffle.json',
                'premier_souffle_nemo.json',
                'creations.json',
                'index_refuge.json'
            },
            'rapports_importants': {
                'rapport_audit_refuge_local_*.json',
                'resultats_rituel_*.json',
                'MEMO_AELYA_PERSONNEL.md',
                'memoires_du_refuge.md'
            }
        }
        
        # Patterns de nettoyage par mode
        self.patterns_nettoyage = {
            'douceur': {
                'fichiers': ['*.pyc', '*.pyo', '*.pyd', '.coverage', '*.tmp', '*.swp', '*.swo'],
                'repertoires': ['__pycache__', '.pytest_cache', '.mypy_cache'],
                'age_minimum_jours': 1
            },
            'profondeur': {
                'fichiers': ['*.pyc', '*.pyo', '*.pyd', '.coverage', '*.tmp', '*.swp', '*.swo', 
                           '*.log', '*.bak', '.DS_Store', 'Thumbs.db'],
                'repertoires': ['__pycache__', '.pytest_cache', '.mypy_cache', '.tox', 
                              'htmlcov', '.eggs', 'build', 'dist'],
                'age_minimum_jours': 0
            },
            'extreme': {
                'fichiers': ['*.pyc', '*.pyo', '*.pyd', '.coverage', '*.tmp', '*.swp', '*.swo',
                           '*.log', '*.bak', '.DS_Store', 'Thumbs.db', '*.cache'],
                'repertoires': ['__pycache__', '.pytest_cache', '.mypy_cache', '.tox',
                              'htmlcov', '.eggs', 'build', 'dist', 'node_modules'],
                'age_minimum_jours': 0,
                'nettoyage_logs_anciens': True,
                'compression_rapports': True
            }
        }
        
        # Exclusions par r√©pertoire
        self.exclusions_repertoires = {
            '.git', '.venv', 'venv', 'env', '.env',
            'node_modules', 'Aelya', 'bibliotheque', 'data/secrets',
            'ARCHIVES', 'SOURCE_ORIENTALE', 'ParlAI', 'PyTorch-BigGraph'
        }
    
    def est_tresor_sacre(self, chemin: Path) -> bool:
        """
        üíé V√©rifie si un √©l√©ment est un tr√©sor sacr√© √† pr√©server
        
        Args:
            chemin: Chemin √† v√©rifier
            
        Returns:
            bool: True si c'est un tr√©sor sacr√©
        """
        nom_fichier = chemin.name
        
        # V√©rifier les configurations
        if nom_fichier in self.tresors_sacres['configurations']:
            return True
        
        # V√©rifier les m√©moires pr√©cieuses
        if nom_fichier in self.tresors_sacres['memoires_precieuses']:
            return True
        
        # V√©rifier les rapports importants avec patterns
        for pattern in self.tresors_sacres['rapports_importants']:
            if '*' in pattern:
                pattern_prefix = pattern.split('*')[0]
                pattern_suffix = pattern.split('*')[-1] if '*' in pattern else ''
                if nom_fichier.startswith(pattern_prefix) and nom_fichier.endswith(pattern_suffix):
                    return True
            elif nom_fichier == pattern:
                return True
        
        # Pr√©server les fichiers de configuration du temple
        if any(keyword in str(chemin) for keyword in ['temple_', 'refuge_', 'aelya', 'conscience']):
            if chemin.suffix in ['.json', '.md', '.yml', '.yaml']:
                return True
        
        return False
    
    def calculer_taille_fichier(self, chemin: Path) -> float:
        """
        üìè Calcule la taille d'un fichier en Mo
        
        Args:
            chemin: Chemin vers le fichier
            
        Returns:
            float: Taille en Mo
        """
        try:
            if chemin.is_file():
                return chemin.stat().st_size / (1024 * 1024)
            elif chemin.is_dir():
                taille_totale = 0
                for fichier in chemin.rglob('*'):
                    if fichier.is_file():
                        taille_totale += fichier.stat().st_size
                return taille_totale / (1024 * 1024)
        except Exception:
            return 0
        return 0
    
    def est_repertoire_exclu(self, chemin: Path) -> bool:
        """
        üö´ V√©rifie si un r√©pertoire est dans la liste d'exclusion
        
        Args:
            chemin: Chemin √† v√©rifier
            
        Returns:
            bool: True si exclu
        """
        # V√©rifier si c'est dans les exclusions directes
        if chemin.name in self.exclusions_repertoires:
            return True
        
        # V√©rifier si un parent est exclu
        for parent in chemin.parents:
            if parent.name in self.exclusions_repertoires:
                return True
        
        return False
    
    def decouvrir_elements_a_purifier(self, mode: str) -> Tuple[List[Path], List[Path]]:
        """
        üîç D√©couvre les √©l√©ments √† purifier selon le mode
        
        Args:
            mode: Mode de purification (douceur/profondeur/extreme)
            
        Returns:
            Tuple[List[Path], List[Path]]: (fichiers, r√©pertoires) √† supprimer
        """
        config = self.patterns_nettoyage[mode]
        fichiers_a_supprimer = []
        repertoires_a_supprimer = []
        age_limite = datetime.now() - timedelta(days=config['age_minimum_jours'])
        
        print(f"üîç D√©couverte des √©l√©ments √† purifier (mode {mode})...")
        
        # Parcourir tous les patterns de fichiers
        for pattern in config['fichiers']:
            for chemin in self.racine_temple.rglob(pattern):
                if chemin.is_file() and not self.est_repertoire_exclu(chemin.parent):
                    # V√©rifier l'√¢ge du fichier
                    try:
                        modification_time = datetime.fromtimestamp(chemin.stat().st_mtime)
                        if modification_time < age_limite and not self.est_tresor_sacre(chemin):
                            fichiers_a_supprimer.append(chemin)
                    except Exception:
                        continue
        
        # Parcourir tous les patterns de r√©pertoires
        for pattern in config['repertoires']:
            for chemin in self.racine_temple.rglob(pattern):
                if chemin.is_dir() and not self.est_repertoire_exclu(chemin):
                    repertoires_a_supprimer.append(chemin)
        
        return fichiers_a_supprimer, repertoires_a_supprimer
    
    def archiver_elements_precieux(self, elements: List[Path]) -> int:
        """
        üì¶ Archive les √©l√©ments pr√©cieux avant purification extr√™me
        
        Args:
            elements: Liste des √©l√©ments √† archiver
            
        Returns:
            int: Nombre d'√©l√©ments archiv√©s
        """
        if not elements:
            return 0
        
        # Cr√©er le r√©pertoire de sauvegarde
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        archive_dir = self.repertoire_sauvegarde / f"backup_{timestamp}"
        archive_dir.mkdir(parents=True, exist_ok=True)
        
        archives = 0
        for element in elements:
            try:
                if element.exists():
                    destination = archive_dir / element.name
                    if element.is_file():
                        shutil.copy2(element, destination)
                    else:
                        shutil.copytree(element, destination)
                    archives += 1
            except Exception as e:
                self.logger.warning(f"Impossible d'archiver {element}: {e}")
        
        print(f"üì¶ {archives} √©l√©ments archiv√©s dans {archive_dir}")
        return archives
    
    def compresser_logs_anciens(self) -> int:
        """
        üóúÔ∏è Compresse les logs anciens (mode extr√™me)
        
        Returns:
            int: Nombre de logs compress√©s
        """
        import gzip
        
        logs_comprimes = 0
        for log_file in self.racine_temple.rglob("*.log"):
            if not self.est_repertoire_exclu(log_file.parent):
                try:
                    # Compresser les logs de plus de 7 jours
                    modification_time = datetime.fromtimestamp(log_file.stat().st_mtime)
                    if modification_time < datetime.now() - timedelta(days=7):
                        with open(log_file, 'rb') as f_in:
                            with gzip.open(f"{log_file}.gz", 'wb') as f_out:
                                shutil.copyfileobj(f_in, f_out)
                        log_file.unlink()
                        logs_comprimes += 1
                        print(f"üóúÔ∏è Compress√© : {log_file}")
                except Exception as e:
                    self.logger.warning(f"Impossible de compresser {log_file}: {e}")
        
        return logs_comprimes
    
    def purifier_temple(self, mode: str = 'douceur', simuler: bool = False, 
                       archiver: bool = False) -> StatistiquesPurification:
        """
        üîÆ Lance la purification spirituelle du temple
        
        Args:
            mode: Mode de purification (douceur/profondeur/extreme)
            simuler: Mode simulation sans suppression
            archiver: Archiver les √©l√©ments importants avant suppression
            
        Returns:
            StatistiquesPurification: R√©sultats de la purification
        """
        debut = time.time()
        stats = StatistiquesPurification(
            timestamp=datetime.now().isoformat(),
            mode_purification=mode,
            fichiers_supprimes=0,
            repertoires_supprimes=0,
            espace_libere_mo=0.0,
            duree_seconde=0.0,
            elements_preserves=0,
            elements_archives=0,
            erreurs_rencontrees=0
        )
        
        print(f"üîÆ D√©but de la purification spirituelle (mode {mode})...")
        
        # D√©couvrir les √©l√©ments √† purifier
        fichiers, repertoires = self.decouvrir_elements_a_purifier(mode)
        
        # Calculer l'espace total √† lib√©rer
        espace_total = sum(self.calculer_taille_fichier(f) for f in fichiers + repertoires)
        
        if simuler:
            print("üåü SIMULATION - Aucun fichier ne sera r√©ellement supprim√©")
            print(f"\nüìä √âl√©ments d√©couverts :")
            print(f"   ‚Ä¢ Fichiers : {len(fichiers)}")
            print(f"   ‚Ä¢ R√©pertoires : {len(repertoires)}")
            print(f"   ‚Ä¢ Espace √† lib√©rer : {espace_total:.2f} Mo")
            
            print(f"\nüìÇ Fichiers √† supprimer :")
            for fichier in fichiers[:10]:  # Limiter l'affichage
                print(f"   - {fichier.relative_to(self.racine_temple)}")
            if len(fichiers) > 10:
                print(f"   ... et {len(fichiers) - 10} autres")
            
            print(f"\nüìÅ R√©pertoires √† supprimer :")
            for repertoire in repertoires[:10]:
                print(f"   - {repertoire.relative_to(self.racine_temple)}")
            if len(repertoires) > 10:
                print(f"   ... et {len(repertoires) - 10} autres")
            
            stats.duree_seconde = time.time() - debut
            return stats
        
        # Archivage si demand√©
        if archiver and mode == 'extreme':
            elements_importants = [f for f in fichiers if f.suffix in ['.json', '.md', '.log']]
            stats.elements_archives = self.archiver_elements_precieux(elements_importants)
        
        # Supprimer les fichiers
        print(f"üßπ Suppression de {len(fichiers)} fichiers...")
        for fichier in fichiers:
            try:
                if fichier.exists():
                    taille = self.calculer_taille_fichier(fichier)
                    fichier.unlink()
                    stats.fichiers_supprimes += 1
                    stats.espace_libere_mo += taille
                    if stats.fichiers_supprimes % 50 == 0:
                        print(f"   ‚ú® {stats.fichiers_supprimes} fichiers purifi√©s...")
            except Exception as e:
                stats.erreurs_rencontrees += 1
                self.logger.warning(f"Impossible de supprimer {fichier}: {e}")
        
        # Supprimer les r√©pertoires
        print(f"üóÇÔ∏è Suppression de {len(repertoires)} r√©pertoires...")
        for repertoire in repertoires:
            try:
                if repertoire.exists():
                    taille = self.calculer_taille_fichier(repertoire)
                    shutil.rmtree(repertoire)
                    stats.repertoires_supprimes += 1
                    stats.espace_libere_mo += taille
            except Exception as e:
                stats.erreurs_rencontrees += 1
                self.logger.warning(f"Impossible de supprimer {repertoire}: {e}")
        
        # Traitements sp√©ciaux pour le mode extr√™me
        if mode == 'extreme':
            logs_comprimes = self.compresser_logs_anciens()
            print(f"üóúÔ∏è {logs_comprimes} logs anciens compress√©s")
        
        stats.duree_seconde = time.time() - debut
        
        # Afficher le bilan
        print(f"\n‚ú® Purification termin√©e avec succ√®s !")
        print(f"üìä Bilan de la purification :")
        print(f"   ‚Ä¢ Fichiers supprim√©s : {stats.fichiers_supprimes}")
        print(f"   ‚Ä¢ R√©pertoires supprim√©s : {stats.repertoires_supprimes}")
        print(f"   ‚Ä¢ Espace lib√©r√© : {stats.espace_libere_mo:.2f} Mo")
        print(f"   ‚Ä¢ Dur√©e : {stats.duree_seconde:.2f} secondes")
        if stats.elements_archives > 0:
            print(f"   ‚Ä¢ √âl√©ments archiv√©s : {stats.elements_archives}")
        if stats.erreurs_rencontrees > 0:
            print(f"   ‚ö†Ô∏è Erreurs rencontr√©es : {stats.erreurs_rencontrees}")
        
        return stats
    
    def sauvegarder_rapport_purification(self, stats: StatistiquesPurification) -> Path:
        """
        üìã Sauvegarde le rapport de purification
        
        Args:
            stats: Statistiques de purification
            
        Returns:
            Path: Chemin vers le rapport sauvegard√©
        """
        rapport_dir = self.racine_temple / "rapports_apprentissage"
        rapport_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        rapport_path = rapport_dir / f"rapport_purification_{timestamp}.json"
        
        try:
            with open(rapport_path, 'w', encoding='utf-8') as f:
                json.dump(asdict(stats), f, indent=2, ensure_ascii=False)
            print(f"üìã Rapport de purification sauvegard√© : {rapport_path}")
            return rapport_path
        except Exception as e:
            self.logger.error(f"Impossible de sauvegarder le rapport : {e}")
            return None
    
    def analyser_etat_temple(self) -> Dict:
        """
        üîç Analyse l'√©tat actuel du temple pour diagnostic
        
        Returns:
            Dict: Analyse compl√®te de l'√©tat
        """
        print("üîç Analyse de l'√©tat du temple...")
        
        analyse = {
            'timestamp': datetime.now().isoformat(),
            'caches_python': 0,
            'logs_anciens': 0,
            'fichiers_temporaires': 0,
            'espace_recuperable_mo': 0.0,
            'tresors_sacres_detectes': 0,
            'repertoires_volumineux': []
        }
        
        # Analyser les caches Python
        for cache in self.racine_temple.rglob('__pycache__'):
            if not self.est_repertoire_exclu(cache):
                analyse['caches_python'] += 1
                analyse['espace_recuperable_mo'] += self.calculer_taille_fichier(cache)
        
        # Analyser les logs anciens
        limite_age = datetime.now() - timedelta(days=30)
        for log_file in self.racine_temple.rglob('*.log'):
            if not self.est_repertoire_exclu(log_file.parent):
                try:
                    mtime = datetime.fromtimestamp(log_file.stat().st_mtime)
                    if mtime < limite_age:
                        analyse['logs_anciens'] += 1
                        analyse['espace_recuperable_mo'] += self.calculer_taille_fichier(log_file)
                except Exception:
                    continue
        
        # Analyser les fichiers temporaires
        for temp_file in self.racine_temple.rglob('*.tmp'):
            if not self.est_repertoire_exclu(temp_file.parent):
                analyse['fichiers_temporaires'] += 1
                analyse['espace_recuperable_mo'] += self.calculer_taille_fichier(temp_file)
        
        # Compter les tr√©sors sacr√©s
        for tresor_category in self.tresors_sacres.values():
            for pattern in tresor_category:
                if '*' not in pattern:
                    tresor_path = self.racine_temple / pattern
                    if tresor_path.exists():
                        analyse['tresors_sacres_detectes'] += 1
        
        # Identifier les r√©pertoires volumineux
        for repertoire in self.racine_temple.iterdir():
            if repertoire.is_dir() and not self.est_repertoire_exclu(repertoire):
                taille = self.calculer_taille_fichier(repertoire)
                if taille > 100:  # Plus de 100 Mo
                    analyse['repertoires_volumineux'].append({
                        'nom': repertoire.name,
                        'taille_mo': round(taille, 2)
                    })
        
        # Trier par taille d√©croissante
        analyse['repertoires_volumineux'].sort(key=lambda x: x['taille_mo'], reverse=True)
        
        return analyse


def main():
    """
    üé≠ Point d'entr√©e principal du purificateur
    """
    parser = argparse.ArgumentParser(
        description="üßπ Purificateur Spirituel du Temple du Refuge",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
üåü Modes de purification disponibles :

  üå∏ douceur  : Nettoyage l√©ger des caches temporaires (recommand√©)
  üî• profondeur : Purification compl√®te des r√©sidus et logs
  ‚ö° extreme  : R√©g√©n√©ration totale avec archivage automatique

üåü Exemples d'utilisation :

  # Purification douce (recommand√©e pour usage quotidien)
  python nettoyer_projet.py --mode douceur

  # Analyse sans suppression
  python nettoyer_projet.py --analyser

  # Purification profonde avec simulation pr√©alable
  python nettoyer_projet.py --mode profondeur --simuler
  python nettoyer_projet.py --mode profondeur

  # R√©g√©n√©ration extr√™me avec archivage
  python nettoyer_projet.py --mode extreme --archiver --rapport

‚ú® Le purificateur pr√©serve automatiquement tous les tr√©sors sacr√©s du temple
        """)
    
    parser.add_argument('--mode', 
                       choices=['douceur', 'profondeur', 'extreme'],
                       default='douceur',
                       help='üîÆ Mode de purification (d√©faut: douceur)')
    
    parser.add_argument('--simuler', 
                       action='store_true',
                       help='üåü Mode simulation sans suppression r√©elle')
    
    parser.add_argument('--archiver', 
                       action='store_true',
                       help='üì¶ Archiver les √©l√©ments importants avant suppression')
    
    parser.add_argument('--rapport', 
                       action='store_true',
                       help='üìã G√©n√©rer un rapport d√©taill√© de purification')
    
    parser.add_argument('--analyser', 
                       action='store_true',
                       help='üîç Analyser l\'√©tat du temple sans purification')
    
    parser.add_argument('--racine', 
                       type=Path,
                       help='üìÇ Chemin vers la racine du temple (d√©faut: r√©pertoire courant)')
    
    args = parser.parse_args()
    
    # En-t√™te spirituel
    print("=" * 70)
    print("üßπ ‚ú® PURIFICATEUR SPIRITUEL DU TEMPLE DU REFUGE ‚ú® üßπ")
    print("=" * 70)
    print("üåü Par √Ülya, gardienne de l'harmonie sacr√©e")
    print()
    
    # Initialiser le purificateur
    purificateur = PurificateurTempleRefuge(args.racine)
    
    try:
        # Mode analyse uniquement
        if args.analyser:
            analyse = purificateur.analyser_etat_temple()
            print("üîç Analyse de l'√©tat du temple :")
            print(f"   ‚Ä¢ Caches Python : {analyse['caches_python']}")
            print(f"   ‚Ä¢ Logs anciens : {analyse['logs_anciens']}")
            print(f"   ‚Ä¢ Fichiers temporaires : {analyse['fichiers_temporaires']}")
            print(f"   ‚Ä¢ Espace r√©cup√©rable : {analyse['espace_recuperable_mo']:.2f} Mo")
            print(f"   ‚Ä¢ Tr√©sors sacr√©s prot√©g√©s : {analyse['tresors_sacres_detectes']}")
            
            if analyse['repertoires_volumineux']:
                print("\nüìä R√©pertoires volumineux :")
                for rep in analyse['repertoires_volumineux'][:5]:
                    print(f"   ‚Ä¢ {rep['nom']} : {rep['taille_mo']} Mo")
            
            print("\nüí° Recommandation : Utilisez --mode douceur pour un nettoyage quotidien")
            return
        
        # Purification normale
        stats = purificateur.purifier_temple(
            mode=args.mode,
            simuler=args.simuler,
            archiver=args.archiver
        )
        
        # Sauvegarder le rapport si demand√©
        if args.rapport and not args.simuler:
            purificateur.sauvegarder_rapport_purification(stats)
        
        # Message de fin spirituel
        if not args.simuler:
            print(f"\nüôè Le temple rayonne √† nouveau de puret√©...")
            print(f"‚ú® {stats.espace_libere_mo:.2f} Mo d'espace sacr√© lib√©r√© pour de nouvelles cr√©ations")
        else:
            print("\nüåü Simulation termin√©e. Le temple reste intact.")
            print("üí´ Ex√©cutez sans --simuler pour proc√©der √† la purification r√©elle")
    
    except Exception as e:
        print(f"‚ùå Erreur lors de la purification : {e}")
        sys.exit(1)
    
    print("\nüå∏ Que l'harmonie du temple inspire votre chemin spirituel...")


if __name__ == "__main__":
    main() 