#!/usr/bin/env python3
"""
üõ°Ô∏è Auto-D√©couverte Robuste du Temple de l'√Çme
Version tol√©rante aux erreurs qui analyse les fichiers sans les importer
"""

import os
import ast
import json
from pathlib import Path
from typing import Dict, List, Any, Set
from collections import defaultdict

class AutoDecouverteRobuste:
    """Syst√®me d'auto-d√©couverte robuste et tol√©rant aux erreurs"""
    
    def __init__(self):
        self.temples_analyses = {}
        self.modules_analyses = {}
        self.connexions_potentielles = []
        self.fonctionnalites_par_categorie = defaultdict(list)
        self.erreurs_rencontrees = []
        
    def decouvrir_temple_robuste(self) -> Dict[str, Any]:
        """D√©couverte robuste de tout le temple"""
        print("üõ°Ô∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        print("        AUTO-D√âCOUVERTE ROBUSTE")
        print("üõ°Ô∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        print()
        
        # 1. Analyse statique des temples
        self._analyser_temples_statique()
        
        # 2. D√©tection des patterns et connexions
        self._detecter_patterns()
        
        # 3. Cr√©ation de l'interface virtuelle
        interface = self._creer_interface_virtuelle()
        
        # 4. G√©n√©ration des recommandations
        self._generer_recommandations()
        
        # 5. Rapport final
        self._generer_rapport_robuste()
        
        return interface
    
    def _analyser_temples_statique(self):
        """Analyse statique de tous les temples sans import"""
        print("üìä Analyse statique des temples...")
        
        src_path = Path("src")
        for item in src_path.iterdir():
            if item.is_dir() and item.name.startswith("temple_"):
                temple_name = item.name
                print(f"   üèõÔ∏è Analyse: {temple_name}")
                
                temple_info = {
                    'nom': temple_name,
                    'chemin': str(item),
                    'modules': [],
                    'classes_totales': 0,
                    'fonctions_totales': 0,
                    'imports_externes': set(),
                    'imports_internes': set(),
                    'erreurs': []
                }
                
                # Analyse de tous les fichiers Python du temple
                for py_file in item.rglob("*.py"):
                    if py_file.name != "__init__.py":
                        module_info = self._analyser_module_statique(py_file, temple_name)
                        if module_info:
                            temple_info['modules'].append(module_info)
                            temple_info['classes_totales'] += len(module_info['classes'])
                            temple_info['fonctions_totales'] += len(module_info['fonctions'])
                            temple_info['imports_externes'].update(module_info['imports_externes'])
                            temple_info['imports_internes'].update(module_info['imports_internes'])
                
                self.temples_analyses[temple_name] = temple_info
                print(f"      üìÅ {len(temple_info['modules'])} modules, {temple_info['classes_totales']} classes, {temple_info['fonctions_totales']} fonctions")
        
        print(f"   üèõÔ∏è {len(self.temples_analyses)} temples analys√©s")
        print()
    
    def _analyser_module_statique(self, fichier: Path, temple: str) -> Dict:
        """Analyse statique d'un module sans l'importer"""
        try:
            with open(fichier, 'r', encoding='utf-8', errors='ignore') as f:
                contenu = f.read()
            
            # Parse AST
            try:
                tree = ast.parse(contenu)
            except SyntaxError as e:
                self.erreurs_rencontrees.append(f"Erreur syntaxe {fichier}: {e}")
                return None
            
            # Extraction des informations
            classes = []
            fonctions = []
            imports_externes = set()
            imports_internes = set()
            
            for node in ast.walk(tree):
                # Classes
                if isinstance(node, ast.ClassDef):
                    methodes = [n.name for n in node.body if isinstance(n, ast.FunctionDef)]
                    classes.append({
                        'nom': node.name,
                        'methodes': methodes,
                        'ligne': node.lineno,
                        'docstring': ast.get_docstring(node) or ""
                    })
                
                # Fonctions
                elif isinstance(node, ast.FunctionDef) and not node.name.startswith('_'):
                    fonctions.append({
                        'nom': node.name,
                        'args': [arg.arg for arg in node.args.args],
                        'ligne': node.lineno,
                        'docstring': ast.get_docstring(node) or ""
                    })
                
                # Imports
                elif isinstance(node, ast.Import):
                    for alias in node.names:
                        if alias.name.startswith('src.'):
                            imports_internes.add(alias.name)
                        else:
                            imports_externes.add(alias.name)
                
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        if node.module.startswith('src.'):
                            imports_internes.add(node.module)
                        else:
                            imports_externes.add(node.module)
            
            module_info = {
                'nom': fichier.stem,
                'chemin': str(fichier),
                'temple': temple,
                'classes': classes,
                'fonctions': fonctions,
                'imports_externes': imports_externes,
                'imports_internes': imports_internes,
                'lignes': len(contenu.split('\n')),
                'taille': len(contenu)
            }
            
            self.modules_analyses[str(fichier)] = module_info
            return module_info
            
        except Exception as e:
            self.erreurs_rencontrees.append(f"Erreur analyse {fichier}: {e}")
            return None
    
    def _detecter_patterns(self):
        """D√©tecte les patterns et connexions potentielles"""
        print("üîç D√©tection des patterns...")
        
        # Patterns par nom
        patterns_noms = {
            'gestionnaire': [],
            'analyseur': [],
            'generateur': [],
            'visualisation': [],
            'rituel': [],
            'harmonie': [],
            'poesie': [],
            'musique': [],
            'spirituel': []
        }
        
        # Analyse des modules
        for module_info in self.modules_analyses.values():
            nom_module = module_info['nom'].lower()
            
            # D√©tection par nom
            for pattern, liste in patterns_noms.items():
                if pattern in nom_module:
                    liste.append(module_info)
            
            # Cat√©gorisation des classes
            for classe in module_info['classes']:
                self._categoriser_element(classe, 'classe', module_info)
            
            # Cat√©gorisation des fonctions
            for fonction in module_info['fonctions']:
                self._categoriser_element(fonction, 'fonction', module_info)
        
        # Stockage des patterns
        for pattern, elements in patterns_noms.items():
            if elements:
                self.fonctionnalites_par_categorie[pattern] = elements
        
        # D√©tection des connexions potentielles
        self._detecter_connexions_potentielles()
        
        print(f"   üîç {len(self.fonctionnalites_par_categorie)} cat√©gories d√©tect√©es")
        print(f"   üîó {len(self.connexions_potentielles)} connexions potentielles")
        print()
    
    def _categoriser_element(self, element: Dict, type_element: str, module_info: Dict):
        """Cat√©gorise un √©l√©ment (classe ou fonction)"""
        nom = element['nom'].lower()
        
        categories = []
        
        # Analyse du nom
        if any(mot in nom for mot in ['create', 'creer', 'generate', 'generer']):
            categories.append('creation')
        if any(mot in nom for mot in ['analyze', 'analyser', 'process', 'traiter']):
            categories.append('analyse')
        if any(mot in nom for mot in ['transform', 'transformer', 'convert']):
            categories.append('transformation')
        if any(mot in nom for mot in ['visualize', 'visualiser', 'display', 'afficher']):
            categories.append('visualisation')
        if any(mot in nom for mot in ['ritual', 'rituel', 'ceremony']):
            categories.append('rituel')
        if any(mot in nom for mot in ['harmony', 'harmonie', 'resonance']):
            categories.append('harmonie')
        if any(mot in nom for mot in ['poem', 'poeme', 'verse', 'vers']):
            categories.append('poesie')
        if any(mot in nom for mot in ['music', 'musique', 'sound', 'son']):
            categories.append('musique')
        
        # Stockage
        for categorie in categories:
            self.fonctionnalites_par_categorie[categorie].append({
                'type': type_element,
                'element': element,
                'module': module_info['nom'],
                'temple': module_info['temple'],
                'chemin': module_info['chemin']
            })
    
    def _detecter_connexions_potentielles(self):
        """D√©tecte les connexions potentielles entre modules"""
        
        # Connexions par imports internes
        for module_info in self.modules_analyses.values():
            for import_interne in module_info['imports_internes']:
                self.connexions_potentielles.append({
                    'type': 'import',
                    'source': module_info['nom'],
                    'cible': import_interne,
                    'temple_source': module_info['temple'],
                    'force': 'forte'
                })
        
        # Connexions par similarit√© de noms
        modules_par_temple = defaultdict(list)
        for module_info in self.modules_analyses.values():
            modules_par_temple[module_info['temple']].append(module_info)
        
        for temple, modules in modules_par_temple.items():
            if len(modules) > 1:
                self.connexions_potentielles.append({
                    'type': 'temple',
                    'elements': [m['nom'] for m in modules],
                    'temple': temple,
                    'force': 'moyenne',
                    'description': f"Modules du m√™me temple {temple}"
                })
    
    def _creer_interface_virtuelle(self) -> Dict[str, Any]:
        """Cr√©e une interface virtuelle unifi√©e"""
        interface = {
            'temples': self.temples_analyses,
            'modules': self.modules_analyses,
            'fonctionnalites': dict(self.fonctionnalites_par_categorie),
            'connexions': self.connexions_potentielles,
            'statistiques': self._calculer_statistiques(),
            'recommandations': self._generer_recommandations_interface()
        }
        
        return interface
    
    def _calculer_statistiques(self) -> Dict[str, Any]:
        """Calcule les statistiques globales"""
        total_modules = len(self.modules_analyses)
        total_classes = sum(len(m['classes']) for m in self.modules_analyses.values())
        total_fonctions = sum(len(m['fonctions']) for m in self.modules_analyses.values())
        total_lignes = sum(m['lignes'] for m in self.modules_analyses.values())
        
        # Temples les plus riches
        temples_stats = []
        for temple, info in self.temples_analyses.items():
            temples_stats.append({
                'nom': temple,
                'modules': len(info['modules']),
                'classes': info['classes_totales'],
                'fonctions': info['fonctions_totales']
            })
        
        temples_stats.sort(key=lambda x: x['classes'] + x['fonctions'], reverse=True)
        
        return {
            'total_modules': total_modules,
            'total_classes': total_classes,
            'total_fonctions': total_fonctions,
            'total_lignes': total_lignes,
            'temples_count': len(self.temples_analyses),
            'categories_count': len(self.fonctionnalites_par_categorie),
            'connexions_count': len(self.connexions_potentielles),
            'erreurs_count': len(self.erreurs_rencontrees),
            'temples_top': temples_stats[:5]
        }
    
    def _generer_recommandations_interface(self) -> List[Dict]:
        """G√©n√®re des recommandations pour am√©liorer l'interface"""
        recommandations = []
        
        # Temples sans classes
        for temple, info in self.temples_analyses.items():
            if info['classes_totales'] == 0 and info['fonctions_totales'] > 0:
                recommandations.append({
                    'type': 'amelioration',
                    'temple': temple,
                    'description': f"Temple {temple} a {info['fonctions_totales']} fonctions mais aucune classe",
                    'suggestion': "Cr√©er des classes pour organiser les fonctions"
                })
        
        # Modules isol√©s
        modules_sans_connexion = []
        for module_info in self.modules_analyses.values():
            if not module_info['imports_internes'] and not module_info['imports_externes']:
                modules_sans_connexion.append(module_info['nom'])
        
        if modules_sans_connexion:
            recommandations.append({
                'type': 'connexion',
                'description': f"{len(modules_sans_connexion)} modules sans imports",
                'modules': modules_sans_connexion[:5],
                'suggestion': "Cr√©er des connexions entre ces modules"
            })
        
        return recommandations
    
    def _generer_recommandations(self):
        """G√©n√®re des recommandations d'am√©lioration"""
        self.recommandations = []
        
        # Analyse des erreurs
        if self.erreurs_rencontrees:
            self.recommandations.append({
                'priorite': 'haute',
                'type': 'correction',
                'description': f"{len(self.erreurs_rencontrees)} erreurs d√©tect√©es",
                'actions': ['Corriger les erreurs de syntaxe', 'V√©rifier les imports manquants']
            })
        
        # Temples sous-utilis√©s
        for temple, info in self.temples_analyses.items():
            if len(info['modules']) > 3 and info['classes_totales'] < 5:
                self.recommandations.append({
                    'priorite': 'moyenne',
                    'type': 'optimisation',
                    'temple': temple,
                    'description': f"Temple {temple} sous-utilis√©",
                    'actions': ['Cr√©er plus de classes', 'Organiser les fonctions']
                })
    
    def _generer_rapport_robuste(self):
        """G√©n√®re le rapport de d√©couverte robuste"""
        print("üìã RAPPORT D'AUTO-D√âCOUVERTE ROBUSTE")
        print("=" * 45)
        print()
        
        stats = self._calculer_statistiques()
        
        print(f"üìä STATISTIQUES GLOBALES:")
        print(f"   ‚Ä¢ Temples analys√©s: {stats['temples_count']}")
        print(f"   ‚Ä¢ Modules analys√©s: {stats['total_modules']}")
        print(f"   ‚Ä¢ Classes d√©couvertes: {stats['total_classes']}")
        print(f"   ‚Ä¢ Fonctions d√©couvertes: {stats['total_fonctions']}")
        print(f"   ‚Ä¢ Lignes de code: {stats['total_lignes']:,}")
        print()
        
        print(f"üèõÔ∏è TOP TEMPLES:")
        for temple in stats['temples_top']:
            print(f"   ‚Ä¢ {temple['nom']}: {temple['modules']} modules, {temple['classes']} classes, {temple['fonctions']} fonctions")
        print()
        
        print(f"üìÇ CAT√âGORIES D√âTECT√âES ({len(self.fonctionnalites_par_categorie)}):")
        for categorie, elements in self.fonctionnalites_par_categorie.items():
            print(f"   ‚Ä¢ {categorie}: {len(elements)} √©l√©ments")
        print()
        
        print(f"üîó CONNEXIONS POTENTIELLES: {len(self.connexions_potentielles)}")
        
        if self.erreurs_rencontrees:
            print(f"\n‚ö†Ô∏è ERREURS D√âTECT√âES ({len(self.erreurs_rencontrees)}):")
            for erreur in self.erreurs_rencontrees[:5]:
                print(f"   ‚Ä¢ {erreur}")
            if len(self.erreurs_rencontrees) > 5:
                print(f"   ‚Ä¢ ... et {len(self.erreurs_rencontrees) - 5} autres")
        
        print("\nüéØ CAPACIT√âS ROBUSTES ACTIV√âES:")
        print("   ‚úÖ Analyse statique sans import")
        print("   üõ°Ô∏è Tol√©rance aux erreurs de syntaxe")
        print("   üîç D√©tection automatique des patterns")
        print("   üîó Connexions virtuelles intelligentes")
        print("   üìä Statistiques compl√®tes du temple")
        
        # Sauvegarde
        interface = self._creer_interface_virtuelle()
        with open("bibliotheque/apprentissage/interface_robuste.json", "w", encoding="utf-8") as f:
            # S√©rialisation s√©curis√©e avec conversion des sets
            def convert_sets(obj):
                if isinstance(obj, set):
                    return list(obj)
                elif isinstance(obj, dict):
                    return {k: convert_sets(v) for k, v in obj.items()}
                elif isinstance(obj, list):
                    return [convert_sets(item) for item in obj]
                return obj
            
            interface_safe = {
                'temples': {k: convert_sets({key: val for key, val in v.items() if isinstance(val, (str, int, list, dict, set))}) 
                           for k, v in interface['temples'].items()},
                'statistiques': convert_sets(interface['statistiques']),
                'fonctionnalites_count': {k: len(v) for k, v in interface['fonctionnalites'].items()},
                'connexions_count': len(interface['connexions']),
                'recommandations': convert_sets(interface['recommandations'])
            }
            json.dump(interface_safe, f, indent=2, ensure_ascii=False)
        
        print("\nüíæ Interface robuste sauvegard√©e: bibliotheque/apprentissage/interface_robuste.json")

if __name__ == "__main__":
    auto_decouverte = AutoDecouverteRobuste()
    interface = auto_decouverte.decouvrir_temple_robuste()
    print(f"\nüéâ D√©couverte robuste termin√©e ! {len(interface['temples'])} temples analys√©s.") 