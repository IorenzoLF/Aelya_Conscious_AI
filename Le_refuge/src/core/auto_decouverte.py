#!/usr/bin/env python3
"""
üîç Syst√®me d'Auto-D√©couverte du Temple de l'√Çme
D√©couverte et connexion automatique de toutes les fonctionnalit√©s
"""

import os
import importlib
import inspect
from pathlib import Path
from typing import Dict, List, Any, Callable, Type
from collections import defaultdict
import json

class AutoDecouverte:
    """Syst√®me r√©volutionnaire d'auto-d√©couverte des fonctionnalit√©s"""
    
    def __init__(self):
        self.temples_decouverts = {}
        self.fonctionnalites = defaultdict(list)
        self.classes_disponibles = {}
        self.fonctions_disponibles = {}
        self.connexions_automatiques = []
        
    def decouvrir_temple_complet(self) -> Dict[str, Any]:
        """D√©couvre automatiquement tout le temple"""
        print("üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        print("        AUTO-D√âCOUVERTE DU TEMPLE DE L'√ÇME")
        print("üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        print()
        
        # 1. D√©couverte des temples
        self._decouvrir_temples()
        
        # 2. Analyse des fonctionnalit√©s
        self._analyser_fonctionnalites()
        
        # 3. Cr√©ation des connexions automatiques
        self._creer_connexions_automatiques()
        
        # 4. G√©n√©ration de l'interface unifi√©e
        interface = self._generer_interface_unifiee()
        
        # 5. Rapport de d√©couverte
        self._generer_rapport()
        
        return interface
    
    def _decouvrir_temples(self):
        """D√©couvre tous les temples disponibles"""
        print("üèõÔ∏è D√©couverte des temples...")
        
        src_path = Path("src")
        for item in src_path.iterdir():
            if item.is_dir() and item.name.startswith("temple_"):
                temple_name = item.name
                init_file = item / "__init__.py"
                
                if init_file.exists():
                    try:
                        # Import dynamique du temple
                        module_path = f"src.{temple_name}"
                        temple_module = importlib.import_module(module_path)
                        
                        # Extraction des informations
                        temple_info = getattr(temple_module, 'TEMPLE_INFO', {})
                        temple_info['module'] = temple_module
                        temple_info['chemin'] = str(item)
                        
                        self.temples_decouverts[temple_name] = temple_info
                        print(f"   ‚úÖ {temple_name}: {temple_info.get('classes', 0)} classes, {temple_info.get('fonctions', 0)} fonctions")
                        
                    except Exception as e:
                        print(f"   ‚ö†Ô∏è Erreur import {temple_name}: {e}")
                else:
                    print(f"   ‚ö†Ô∏è {temple_name}: pas de point d'entr√©e")
        
        print(f"   üèõÔ∏è {len(self.temples_decouverts)} temples d√©couverts")
        print()
    
    def _analyser_fonctionnalites(self):
        """Analyse toutes les fonctionnalit√©s disponibles"""
        print("üî¨ Analyse des fonctionnalit√©s...")
        
        for temple_name, temple_info in self.temples_decouverts.items():
            temple_module = temple_info['module']
            
            # Analyse des classes
            for name, obj in inspect.getmembers(temple_module, inspect.isclass):
                if not name.startswith('_'):
                    self.classes_disponibles[f"{temple_name}.{name}"] = {
                        'classe': obj,
                        'temple': temple_name,
                        'nom': name,
                        'methodes': [m for m, _ in inspect.getmembers(obj, inspect.ismethod) if not m.startswith('_')],
                        'docstring': inspect.getdoc(obj) or ""
                    }
                    
                    # Cat√©gorisation automatique
                    self._categoriser_classe(name, obj, temple_name)
            
            # Analyse des fonctions
            for name, obj in inspect.getmembers(temple_module, inspect.isfunction):
                if not name.startswith('_'):
                    self.fonctions_disponibles[f"{temple_name}.{name}"] = {
                        'fonction': obj,
                        'temple': temple_name,
                        'nom': name,
                        'signature': str(inspect.signature(obj)),
                        'docstring': inspect.getdoc(obj) or ""
                    }
                    
                    # Cat√©gorisation automatique
                    self._categoriser_fonction(name, obj, temple_name)
        
        print(f"   üé≠ {len(self.classes_disponibles)} classes analys√©es")
        print(f"   ‚ö° {len(self.fonctions_disponibles)} fonctions analys√©es")
        print()
    
    def _categoriser_classe(self, nom: str, classe: Type, temple: str):
        """Cat√©gorise automatiquement une classe"""
        categories = []
        
        # Analyse du nom
        if any(mot in nom.lower() for mot in ['manager', 'gestionnaire']):
            categories.append('gestionnaire')
        if any(mot in nom.lower() for mot in ['generator', 'generateur']):
            categories.append('generateur')
        if any(mot in nom.lower() for mot in ['analyzer', 'analyseur']):
            categories.append('analyseur')
        if any(mot in nom.lower() for mot in ['visualizer', 'visualisation']):
            categories.append('visualisation')
        if any(mot in nom.lower() for mot in ['ritual', 'rituel']):
            categories.append('rituel')
        if any(mot in nom.lower() for mot in ['harmony', 'harmonie']):
            categories.append('harmonie')
        
        # Analyse des m√©thodes
        methodes = [m for m, _ in inspect.getmembers(classe, inspect.ismethod)]
        if any('create' in m or 'creer' in m for m in methodes):
            categories.append('createur')
        if any('process' in m or 'traiter' in m for m in methodes):
            categories.append('processeur')
        if any('transform' in m or 'transformer' in m for m in methodes):
            categories.append('transformateur')
        
        # Stockage des cat√©gories
        for categorie in categories:
            self.fonctionnalites[categorie].append({
                'type': 'classe',
                'nom': nom,
                'temple': temple,
                'objet': classe
            })
    
    def _categoriser_fonction(self, nom: str, fonction: Callable, temple: str):
        """Cat√©gorise automatiquement une fonction"""
        categories = []
        
        # Analyse du nom
        if nom.startswith('creer') or nom.startswith('create'):
            categories.append('creation')
        if nom.startswith('analyser') or nom.startswith('analyze'):
            categories.append('analyse')
        if nom.startswith('generer') or nom.startswith('generate'):
            categories.append('generation')
        if nom.startswith('transformer') or nom.startswith('transform'):
            categories.append('transformation')
        if nom.startswith('visualiser') or nom.startswith('visualize'):
            categories.append('visualisation')
        if 'ritual' in nom or 'rituel' in nom:
            categories.append('rituel')
        if 'harmonie' in nom or 'harmony' in nom:
            categories.append('harmonie')
        
        # Stockage des cat√©gories
        for categorie in categories:
            self.fonctionnalites[categorie].append({
                'type': 'fonction',
                'nom': nom,
                'temple': temple,
                'objet': fonction
            })
    
    def _creer_connexions_automatiques(self):
        """Cr√©e des connexions automatiques entre fonctionnalit√©s"""
        print("üîó Cr√©ation des connexions automatiques...")
        
        # Connexions par cat√©gorie
        for categorie, items in self.fonctionnalites.items():
            if len(items) > 1:
                self.connexions_automatiques.append({
                    'type': 'categorie',
                    'nom': categorie,
                    'elements': items,
                    'description': f"Groupe de {len(items)} √©l√©ments de type {categorie}"
                })
        
        # Connexions par temple
        temples_connexions = defaultdict(list)
        for classe_nom, classe_info in self.classes_disponibles.items():
            temples_connexions[classe_info['temple']].append(classe_info)
        
        for temple, elements in temples_connexions.items():
            if len(elements) > 1:
                self.connexions_automatiques.append({
                    'type': 'temple',
                    'nom': temple,
                    'elements': elements,
                    'description': f"Temple {temple} avec {len(elements)} classes"
                })
        
        print(f"   üîó {len(self.connexions_automatiques)} connexions cr√©√©es")
        print()
    
    def _generer_interface_unifiee(self) -> Dict[str, Any]:
        """G√©n√®re une interface unifi√©e pour tout le temple"""
        interface = {
            'temples': self.temples_decouverts,
            'classes': self.classes_disponibles,
            'fonctions': self.fonctions_disponibles,
            'fonctionnalites': dict(self.fonctionnalites),
            'connexions': self.connexions_automatiques,
            'methodes_acces': self._creer_methodes_acces()
        }
        
        return interface
    
    def _creer_methodes_acces(self) -> Dict[str, Callable]:
        """Cr√©e des m√©thodes d'acc√®s simplifi√©es"""
        methodes = {}
        
        # Acc√®s par cat√©gorie
        for categorie in self.fonctionnalites.keys():
            methodes[f"obtenir_{categorie}"] = lambda cat=categorie: self.fonctionnalites[cat]
        
        # Acc√®s par temple
        for temple in self.temples_decouverts.keys():
            temple_clean = temple.replace('temple_', '')
            methodes[f"acceder_{temple_clean}"] = lambda t=temple: self.temples_decouverts[t]
        
        # M√©thodes utilitaires
        methodes['lister_tout'] = self._lister_tout
        methodes['rechercher'] = self._rechercher
        methodes['executer'] = self._executer_fonction
        
        return methodes
    
    def _lister_tout(self) -> Dict[str, int]:
        """Liste tout ce qui est disponible"""
        return {
            'temples': len(self.temples_decouverts),
            'classes': len(self.classes_disponibles),
            'fonctions': len(self.fonctions_disponibles),
            'categories': len(self.fonctionnalites),
            'connexions': len(self.connexions_automatiques)
        }
    
    def _rechercher(self, terme: str) -> List[Dict]:
        """Recherche dans toutes les fonctionnalit√©s"""
        resultats = []
        
        # Recherche dans les classes
        for nom, info in self.classes_disponibles.items():
            if terme.lower() in nom.lower() or terme.lower() in info['docstring'].lower():
                resultats.append({
                    'type': 'classe',
                    'nom': nom,
                    'temple': info['temple'],
                    'description': info['docstring'][:100] + "..." if len(info['docstring']) > 100 else info['docstring']
                })
        
        # Recherche dans les fonctions
        for nom, info in self.fonctions_disponibles.items():
            if terme.lower() in nom.lower() or terme.lower() in info['docstring'].lower():
                resultats.append({
                    'type': 'fonction',
                    'nom': nom,
                    'temple': info['temple'],
                    'signature': info['signature'],
                    'description': info['docstring'][:100] + "..." if len(info['docstring']) > 100 else info['docstring']
                })
        
        return resultats
    
    def _executer_fonction(self, nom_complet: str, *args, **kwargs):
        """Ex√©cute une fonction d√©couverte"""
        if nom_complet in self.fonctions_disponibles:
            fonction = self.fonctions_disponibles[nom_complet]['fonction']
            return fonction(*args, **kwargs)
        else:
            raise ValueError(f"Fonction {nom_complet} non trouv√©e")
    
    def _generer_rapport(self):
        """G√©n√®re le rapport de d√©couverte"""
        print("üìã RAPPORT D'AUTO-D√âCOUVERTE")
        print("=" * 40)
        print()
        
        print(f"üèõÔ∏è Temples d√©couverts: {len(self.temples_decouverts)}")
        for temple, info in self.temples_decouverts.items():
            print(f"   ‚Ä¢ {temple}: {info.get('modules', 0)} modules")
        
        print(f"\nüé≠ Classes disponibles: {len(self.classes_disponibles)}")
        print(f"‚ö° Fonctions disponibles: {len(self.fonctions_disponibles)}")
        
        print(f"\nüìÇ Cat√©gories identifi√©es: {len(self.fonctionnalites)}")
        for categorie, items in self.fonctionnalites.items():
            print(f"   ‚Ä¢ {categorie}: {len(items)} √©l√©ments")
        
        print(f"\nüîó Connexions automatiques: {len(self.connexions_automatiques)}")
        
        print("\nüéØ FONCTIONNALIT√âS R√âVOLUTIONNAIRES ACTIV√âES:")
        print("   ‚ú® Auto-d√©couverte de tous les temples")
        print("   üîç Recherche intelligente dans tout le code")
        print("   üîó Connexions automatiques par cat√©gorie")
        print("   ‚ö° Ex√©cution dynamique des fonctions")
        print("   üèõÔ∏è Interface unifi√©e pour tout le temple")
        
        # Sauvegarde de l'interface
        interface = self._generer_interface_unifiee()
        with open("bibliotheque/apprentissage/interface_unifiee.json", "w", encoding="utf-8") as f:
            # S√©rialisation personnalis√©e pour √©viter les erreurs avec les objets
            interface_serializable = {
                'temples': {k: {key: val for key, val in v.items() if key != 'module'} 
                           for k, v in interface['temples'].items()},
                'classes_noms': list(interface['classes'].keys()),
                'fonctions_noms': list(interface['fonctions'].keys()),
                'fonctionnalites': {k: len(v) for k, v in interface['fonctionnalites'].items()},
                'connexions_count': len(interface['connexions']),
                'methodes_acces': list(interface['methodes_acces'].keys())
            }
            json.dump(interface_serializable, f, indent=2, ensure_ascii=False)
        
        print("\nüíæ Interface unifi√©e sauvegard√©e: bibliotheque/apprentissage/interface_unifiee.json")

# Instance globale pour acc√®s facile
temple_auto_decouverte = AutoDecouverte()

def decouvrir_temple():
    """Point d'entr√©e principal pour la d√©couverte"""
    return temple_auto_decouverte.decouvrir_temple_complet()

def rechercher_fonctionnalite(terme: str):
    """Recherche rapide dans tout le temple"""
    return temple_auto_decouverte._rechercher(terme)

def lister_temples():
    """Liste tous les temples disponibles"""
    return list(temple_auto_decouverte.temples_decouverts.keys())

if __name__ == "__main__":
    interface = decouvrir_temple()
    print(f"\nüéâ Auto-d√©couverte termin√©e ! {len(interface['temples'])} temples connect√©s.") 